# px, em, rem에 대해서 설명해주세요.

- px (픽셀):
  1. px는 고정된 픽셀 단위
  2. 브라우저 크기를 변경하거나 화면 크기에 따라 크기를 조정하지 않는다. 

- em :
  1. 상대적인 길이 단위로, 현재 요소의 글꼴 크기에 상대적으로 크기를 조정
  2. 만약 부모 요소의 글꼴 크기가 16픽셀이고, 자식 요소의 글꼴 크기를 2em으로 설정하면 자식 요소의 크기는 32px가 된다.
  3. em 단위를 사용할 때, 부모 요소에서 폰트 크기를 명시적으로 설정하지 않았다면, 가장 가까운 상위 부모 요소나 브라우저의 기본 폰트 크기를 기준으로 상대적인 크기가 결정 

- rem :
  1. 상대적인 길이 단위로, 루트 요소의 글꼴 크기에 상대적으로 크기를 조정한다.
  2. rem은 em과 유사하지만 중첩된 요소의 글꼴 크기가 아닌 루트 요소의 글꼴 크기를 기반으로 크기를 조정하기 때문에 예측 가능하고 관리하기 쉽다. 
  3. 루트 글꼴 크기를 설정하는 방법
  ```css
  html {
    font-size: 18px; /* 루트 요소의 글꼴 크기를 18픽셀로 설정 */
  }
  ```

# next.js에서 css를 정의하기 위한 방법 중 선호하는 방식과 왜 그 방식을 선호하는지에 대해 설명해주세요.

1. css module  (css-in-js)
장점. 로컬 스코프
CSS Modules에서 정의된 클래스는 로컬 스코프 내에서만 유효합니다. 즉, 다른 모듈에서 같은 클래스 이름을 사용해도 각각의 모듈에서는 서로 다른 클래스로 취급됩니다. 이로 인해 CSS의 전역 네임스페이스 충돌을 방지할 수 있습니다.

이름 충돌 방지
CSS Modules에서는 자동으로 고유한 클래스 이름을 생성하므로, 클래스 이름이 충돌하는 것을 방지할 수 있습니다.
단점. 동적 변경이 어려움 -> 동적으로 원하는 값을 할당하려면 style 속성을 사용해야 한다. -> 파일 크기의 증가 유발

2. css-in-js
장점. 스타일과 컴포넌트가 결합하여 관리가 용이
styled-components는 스타일과 컴포넌트를 하나의 파일에서 관리할 수 있습니다. 이는 스타일과 컴포넌트의 연관성을 명확히 하고, 관리를 편리하게 합니다.

CSS 클래스 이름 충돌 방지
styled-components는 컴포넌트 내부에서만 스타일이 유효하므로, CSS 클래스 이름 충돌이 발생하지 않습니다. 이는 전역 스타일과 스타일 우선순위 문제를 해결할 수 있습니다.

동적인 스타일링 용이
props를 통해 동적으로 스타일을 변경할 수 있으며, 상태와 함께 사용하면 더욱 다양한 스타일링이 가능합니다.

단점
코드량이 많아질 수록 가독성 저하
하나의 파일에서 스타일링과 컴포넌트를 관리할 수 있다는 점이 장점이 될 수 있지만, 반대로 코드량이 많아질수록 가독성이 저하가 될 수 있습니다.

3. tailwind
장점
빠른 개발 속도
미리 정의된 클래스를 이용하기 때문에 안정된 디자인을 빠르게 구현할 수 있습니다.

일관된 디자인
클래스 기반 스타일링을 사용함으로써, 스타일 규칙이 다른 스타일 규칙과 충돌할 가능성이 낮습니다.

단점
학습 비용 有
미리 정의된 클래스를 사용을 해야 하기 때문에 러닝 커브가 있을 수 있습니다.

적용되는 클래스가 많아질 경우 가독성 하락
하나의 태그에 적용되는 Tailwind CSS 클래스가 많아질 경우 가독성이 하락 할 가능성이 있습니다.

이로 인해 클래스들이 하나의 태그에서 중복될 가능성이 있습니다.

# position에 대해 설명해주세요.

- static: position의 기본값이며, 이를 속성으로 가진 요소는 HTML 문서 상 원래 있어야 하는 위치에 배치된다. 따라서 top, left, bottom, right 속성값은 무시된다.
- relative: 요소를 원래 위치를 기준으로 top, left, bottom, right에 따라 위치를 지정할 수 있다.
- absolute: absolute를 속성으로 가진 요소는 DOM 트리에서 자신의 상위 요소 중 static이 아닌 첫 번째 상위 요소를 배치 기준으로 가진다. 만약 없다면 body가 배치 기준이다. 가장 큰 특징으로는 해당 요소는 독립되어 다른 요소들과 더 이상 상호작용하지 않게 된다는 것이다.
- fixed: 속성값의 배치 기준이 뷰포트, 즉 브라우저 전체 화면인 경우이다. absolute와 마찬가지로 HTML 문서 상에서 독립되어 다른 요소와 상호작용 하지 않는다. 보통 라이브 채팅 버튼을 구현할 때 많이 쓰인다.
- sticky: 가장 최근에 추가된 position 속성으로, 브라우저 화면을 스크롤할 때 효과가 나타난다. 기존에는 relative와 같이 동작하다가 스크롤할 때 지정 지점에서 요소를 고정시킨다. 다만, 자신의 부모 요소 안에서만 적용되며 부모의 height 값에 따라 고정된다. 또한 부모의 overflow가 hidden, auto, scroll 이면 적용이 안 된다.

# Flex와 Grid의 차이점에 대해서 설명해주세요.

Flex는 주로 단일 축 방향의 레이아웃을 구성하는 데 사용되며, 주로 수평 방향으로 레이아웃을 정렬. 
Grid는 2차원 그리드 시스템을 구성하는 데 사용되며, 수평과 수직 방향으로 모두 레이아웃을 정렬 가능 
Flex는 아이템들의 크기가 자유로워 유동적으로 변화 가능. 반면에 Grid는 아이템들의 크기를 미리 정의하여 각 셀의 크기를 일정하게 유지. 
Flex는 유동적인 레이아웃 변화를 구성하기 적합하며, 반면에 Grid는 미리 정의된 2차원 그리드 구조를 유지하기 때문에 레이아웃 변화가 적은 경우에 적합

ex) grid 예제 
```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr); 
  grid-gap: 10px;
}

.item {
  width: 100px;
  height: 100px;
  background-color: lightgreen;
  text-align: center;
  line-height: 100px;
}
```
<code>grid-template-columns: 1fr 2fr 1fr; /* 1fr, 2fr, 1fr의 비율로 열을 설정 */</code>

# CSS에서 margin과 padding에 대해 말해주세요.

- margin: object와 화면 사이의 여백. border의 바깥쪽
- padding: object 내의 여백. content 영역이 배경 색이나 배경 이미지를 가질 때, padding에도 영향을 미치기 때문에 content의 연장으로 볼 수 있다.
게다가 margin은 auto와 음수값을 가질 수 있다.

# CSS Reset과 CSS Normalize

- CSS Reset
    내가 여기서 Reset은 하드 reset을 의미한다. 기존의 브라우저가 제공하는 모든 css 스타일을 없애고 margins, padding 등의 값을 0으로 설정해 아무것도 없는 상태로 만들어준다. 브라우저간의 차이를 생각할 필요없어 변수가 적고 작업속도 면에서 효율적일 수 있다. 다만 코드가 더 길어지고 업데이트가 되지 않는다.
    
- CSS Normalize
    어느 정도 유용한 스타일들은 이용하고 브라우저 간에 상이한 스타일들을 통일시켜준다. github를 통해 지속적으로 업데이트가 돼서 안정성이 높고 버그나 브라우저 간의 차이점이 고려된다. 다만 기존 스타일이 어떻게 사용되는가에 대한 가이드가 따로 없다는 것이 단점 아닌 단점이다.

# 마진 상쇄(Margin Collapsing)의 정의, 원인, 해결 방안

두 개 이상의 Block요소의 상하 마진이 겹쳐질 때 한 쪽 값만 적용되는 브라우저 규칙 (더 큰 마진값으로 상쇄 되어 랜더링됨)

👉 inline, inline-block, table-cell, table-caption 등의 요소는 block-level이 아님

```
예) 30px의 margin만 적용됨.
<div>
  <div style="margin-bottom: 30px"></div>
  <div style="margin-top: 20px"></div>
</div>
```

✅ Block요소의 상/하 마진이 겹칠 때

- 블록 요소의 겹쳐진 두 마진을 비교했을 때, 더 큰 마진의 값으로 상쇄해 랜더링 하게 됩니다. 만약 겹쳐진 값이 동일하다면 그중 하나를 상쇄해 랜더링 하게 됩니다.

✅ 비어있는 요소(height가 0)의 상/하 마진이 겹칠 때

- 높이가 0 인 상태의 블록 요소일 때는 위아래를 가르는 경계선이 없으므로, 자신의 상단 마진의 값과 하단 마진의 값을 비교해 더 큰 값으로 상쇄합니다.
- 높이가 0 인 상태 -> height / padding / border 없는 상태
- 내부에 inline contents가 존재하지 않는 요소일 때

✅ 부모 박스와 자식 박스의 상 하단의 마진이 겹칠 경우

- 부모와 첫 번째 혹은 마지막 자식 사이에 inline 콘텐츠가 없거나, 박스 사이 경계에 padding / border 등의 값이 없다면 마진이 겹치게 되므로, 자식 요소의 마진이 더 크던 작던 상관없이 상쇄된 마진은 부모 박스 바깥으로만 렌더링

🙈 **마진 상쇄 예외**

박스가 position: absolute 된 상태

박스가 float: left/right 된 상태 (단, clear 되지 않은 상태)

박스가 display: flex 일 때 내부 flexbox item

박스가 display: grid 일 때 내부 grid item

✨ **마진 상쇄 해결법**

👉 부모태그에 border, padding 적용

자식태그에 border있어도 적용 안되므로 무조건 부모 태그에 border가 존재해야 됨

But, 부모 자식 사이에서만 마진 상쇄가 막아지는 것이지 다른 컴포넌트와는 막아지지 않음!

👉 display: inline-block을 적용

부모 요소에만 inline-block을 적용할 경우 overflow: hidden 속성도 같이 부여해야 함

👉 flex, grid 사용


# 반응형 페이지 브레이크 포인트란?

브레이크 포인트란 사용자들의 스크린 가로 사이즈가 몇 px인지에 따라 보여줄 내용을 변경시키는 지점이다. 반응형 페이지를 작업한다고 하면 pc, 태블릿, 모바일 세 가지로 나누게 되는데 브레이크 포인트를 설정하기 위해서는 해상도 사용 비율을 알아야 좋은 브레이크 포인트를 설정할 수 있습니다. 아래 사이트에서 세계 해상도 통계를 알아보고 적용할 수있다.

[ https://gs.statcounter.com/ ]

- PC 해상도
사용 비율을 봤을 때 **1920x1080이 대부분**이고 **가장 작은 사이즈는 1280**이므로 1280px사이즈 위로는 pc용 css를 작성해서 보여주면 과반수 이상의 pc이용자들의 편의성을 지켜줄 수 있다
- Tablet 해상도
태블릿의 경우 **pc와 다르게 사이즈가 다양**하다. 수많은 태블릿 제품들이 있기 때문인데 사용율을 보면 601이 가장 많고 나머지는 다 768px 이상이다. 그래서 태블릿은 **768px ~ 1199px로 설정**하면 대다수의 사용자들 편의성을 고려할 수 있다.
- Mobile 해상도
모바일의 경우도 디바이스가 무수히 많기 때문에 사이즈가 다양한데 차트를 보면 **360 사이즈가 가장 작다는 걸** 알 수 있다. 그래서 가장 작은 사이즈는 360, 그리고 태블릿 브레이크 포인트 전인 767까지, **360px ~ 767px를 브레이크 포인트로 설정**하면 대다수의 모바일 사용자들을 고려할 수 있다

# SCSS란?

CSS와 완전히 호환되도록 새로운 구문을 도입한 CSS의 상위 호환 스타일시트이다

- Sass는 CSS로 컴파일 되는 스타일 시트 확장 언어이며 CSS 전처리기의 하나이다.
- 기술 방식에는 `sass` 와 `scss` 가 있는데, `sass` 는 우리가 일반적으로 쓰는 css 문법과 달리 중괄호와 세미콜론을 쓰지 않고 `scss`는 `css`와 완전히 호환되고 새로운 구문을 도입해서 `css`의 상위 호환 스타일시트라고 할 수 있다. 전세계적으로 `scss`가 더 많이 쓰인다.
- scss에서는 여러 파일을 분리하여 코드를 작성할 수 잇다.
- 파일명 앞에 언더바(_)를 붙이면 해당 파일은 컴파일 되지 않는다.
→ style.scss만 컴파일 되도록 한다. 나머지는 내부에서 @import 형태로 작동시킨다.
- `css`가 복잡한 언어는 아니지만 프로젝트의 크기가 커질수록 유지보수에 큰 어려움이 생긴다. 예를 들어 기존의 `CSS`는 불필요한 선택자(Selector), 연산 기능 한계, 구문(Statement)의 부재의 문제점이 있고 `SASS`와 `SCSS`는 이러한 이슈를 해소시켜줄 수 있다.
