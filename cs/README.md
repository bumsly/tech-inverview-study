# OOP의 특징에 대해 설명해주세요.
Object-Oriented Programming
객체지향프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법으로 OOP의 장점은 코드 재사용성이다. 클래스를 한번 만들어 놓으면 계속 이용 가능하고, 상속을 통해 확장 가능하다. 수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 되어 유지보수가 쉽다. 단점은 처리속도가 느리고, 객체가 많으면 용량이 커진다는 것이다. OOP의 특징으로는 클래스와 객체, 캡슐화, 상속 등이 있다. 클래스는 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것이고, 객체 즉 인스턴스는 클래스에서 정의한 것을 토대로 실제 메모리 상에 할당된 데이터이다. 상속은 부모 클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게 하고, 코드의 중복을 없애기 좋다.
OOP의 특징
- 캡슐화(Encapsulation): 한 객체가 특정한 하나의 목적을 위해 필요한 데이터나 메소드를 하나로 묶는 것을 의미한다
- 은닉화(Information hiding): 캡슐화의 목표. 내부 구조는 private하게 감춰두고 외부에서 조작할 수 있는 정보만 public으로 공개한다
- 상속(Inheritance): 기존 메소드와 변수를 물려받되, 필요한 기능을 더 추가하거나 나(자식클래스)에게 맞게 재정의하는 방법
- 추상화(Abstraction): 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- 다형성(Polymorphism): 하나의 변수명이 상황에 따라 다른 의미로 해석될 수 있다는 것을 뜻한다
- 동적바인딩: runtime에 값에 따라 변수 데이터 타입, 호출될 함수가 결정된다

# TDD란 무엇인가? 

TDD(Test-Driven Development)는 테스트 주도 개발 방법론의 준말로, 개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법이다. 
TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움된다.
또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움준다.

### TDD 혹은 테스트 도구를 알려주세요.

1. Jest: Jest는 Facebook에서 만든 JavaScript 테스트 프레임워크이며 React 애플리케이션을 테스트하는 데 널리 사용된다. Jest는 기본적으로 테스트 러너와 어서션 라이브러리를 포함하며, React 컴포넌트를 쉽게 테스트할 수 있는 많은 도구와 기능을 제공한다. Snapshot 테스팅과 모킹(Mocking)을 지원하며, 자동화된 테스트 실행 및 결과 보고 기능도 제공한다.
2. React Testing Library: React Testing Library는 사용자 중심 테스트(User-Centered Testing)를 강조하는 라이브러리로, React 컴포넌트의 행동을 테스트하는 데 중점을 둔다. 사용자의 관점에서 컴포넌트가 어떻게 상호 작용하는지를 테스트하며, 컴포넌트에 더 가까운 접근 방식을 채용한다.
3. Cypress는 엔드 투 엔드(e2e) 테스트를 위한 도구로, React 애플리케이션의 전체 작동을 시뮬레이션하고 테스트하는 데 사용된다. Cypress는 실제 브라우저에서 테스트를 실행하며, 사용자와 같은 방식으로 상호 작용하면서 애플리케이션을 테스트한다.
4. Storybook: Storybook은 React 컴포넌트의 개발 및 문서화를 돕는 데 사용되는 도구이며, 컴포넌트의 시각적 테스트 및 사용자 인터페이스(UI) 테스트를 지원한다. 컴포넌트의 다양한 상태와 시나리오를 시연하고 문서화하는 데 사용할 수 있다.


# 교착 생태란?

운영체제 또는 소프트웨어의 잘못된 자원 관리로 인하여 둘 이상의 프로세스 또는 스레드들이 아무것도 진행하지 않는 상태로 서로 영원히 대기하는 상황으로, 멀티스레딩, 병렬 프로그래밍, 분산 컴퓨팅에서 흔히 발생하는 문제이다. 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

- 데드락이 일어나는 경우

![image](https://github.com/bumsly/tech-inverview-study/assets/65000254/2d8644a8-b47a-45b9-9a31-9ca2227e2959)

프로세스1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자

t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음

t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림

### 데드락(DeadLock) 발생 조건

4가지 모두 성립해야 발생한다.

1. 상호 배제(Mutual exclusion)
    
    > 자원은 한번에 한 프로세스만 사용할 수 있음

2. 점유 대기(Hold and wait)
    
    > 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
 
3. 비선점(No preemption)
    
    > 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

4. 순환 대기(Circular wait)
    
    > 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

### 데드락(DeadLock) 해결 or 예방

- 발생 조건 중에 하나를 제거하면 데드락을 해결할 수 있다. 대신 자원 낭비가 심해질 수 있다.
- 은행원 알고리즘을 사용해 회피한다.
⇒ 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피

# MVC, MVVM 모델에 대해 설명해주세요.
소프트웨어 디자인 패턴, 어플리케이션을 세 개의 영역으로 분할하고 각 구성 요소에게 고유한 역할을 부여하는 개발 방식.

MVC 패턴 (모델, 뷰, 컨트롤러) - 모델은 데이터 및 데이터를 처리하는 부분이고, view는 사용자에게 보여지는 UI 부분이다. 컨트롤러는 사용자의 입력을 받고 처리하는 부분이다. MVC는 사용자의 액션이 컨트롤러에 들어오면, 컨트롤러가 액션을 확인하고 모델을 업데이트한다. 컨트롤러는 모델을 나타내줄 view를 선택하고, view는 모델을 이용하여 화면을 나타낸다. 컨트롤러는 여러 개의 view를 선택할 수 있는 1:n 구조이고, 뷰를 선택할 뿐 직접 업데이트는 하지 않는다.
보편적으로 널리 사용되는 패턴이며, 단점은 뷰와 모델 사이의 의존성이 높고, 어플리케이션이 커질수록 복잡하고, 유지 보수가 어렵다는 점이다.
위의 개념을 WEB에 적용하면,
1. 사용자가 웹사이트에 접속 (Users)
2. Controller는 사용자가 요청한 웹페이지를 서비스하기 위해서 모델을 호출 (Manipulates)
3. Model은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후 그 결과를 Return
4. Controller는 Model이 리턴한 결과를 View에 반영 (Updates)
5. 데이터가 반영된 View는 사용자에게 보여짐 (Sees)

<img src="https://github.com/bumsly/tech-inverview-study/assets/65000254/dfc3de5e-c741-45d0-bb00-cc4f6bdba3d4"  width="500"/>

MVVM 패턴 (모델, 뷰, 뷰모델) - 모델과 뷰는 MVC와 동일하다. 뷰모델은 뷰를 표현하기 위해 만든 모델이다. 또 뷰를 나타내기 위해 데이터 처리를 하는 부분이다. 액션이 뷰를 통해 들어오면, 뷰 모델에 액션을 전달한다. 뷰 모델은 모델에게 데이터를 요청하고, 모델은 요청 받은 데이터를 뷰 모델에게 응답하고, 뷰 모델은 받은 데이터를 가공하여 저장한다. 뷰는 뷰 모델과 데이터 바인딩을 하여 화면을 그리는 동작 방식이다.
이 패턴의 가장 큰 장점은 뷰와 뷰 모델의 의존성을 없애고, 각 부분이 독립적이라는 것이다. 단점은 뷰 모델의 설계가 쉽지 않다는 점이다. 이 패턴의 주요 목적은 로직의 분리이다. 리액트에서는 데이터와 화면 컴포넌트를 분리하는 것을 예시로 들 수 있다.

<img src="https://github.com/bumsly/tech-inverview-study/assets/65000254/7ee58de6-82b0-4def-abe1-0788aeac5742"  width="500"/>

# 시스템 콜에 대해서 설명해주세요.
프로그램 실행 중 유저 모드에서 커널 모드로 전환해서 서비스를 요청하는 것.

프로그램이 무언가 하기 위해서 운영체제(system)를 부르는 것(call)이다.

시스템 콜은 소프트웨어 인터럽트의 일종이다.

모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며, 프로그램이 함수 호출을 하는 경우, 자신의 주소 공간 내에서 호출이 이루어진다.

하지만 시스템 콜은 자신의 주소 공간을 거스르는 영역에 존재하는 함수(시스템 함수)를 호출하는 것을 말한다.

(= 커널 영역의 코드를 실행하는 것을 말한다)

좀 더 구체적으로 정리하자면,

일반적인 함수 호출은 프로그램 자신의 스택 영역을 사용하는 것임에 비해, 시스템 콜은 커널 영역의 함수 위치로 점프를 하는 방식이다. 그 방식은 바로 인터럽트다. 인터럽트 서비스 루틴 또한 커널 영역에 존재한다.

C언어의 printf(), scanf() 도 내부적으로 시스템 콜을 통해 실행된다.

# 기아상태란?

특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태를 말한다.

### 기아상태 해결 방안

- 프로세스 우선순위 수시 변경을 통해 각 프로세스 높은 우선순위를 가지도록 기회 부여
- 오래 기다린 프로세스의 우선순위 높이기
- 우선순위가 아닌 요청 순서대로 처리하는 요청큐 사용

# 메모리 할당 방식

<img width="1000" alt="image" src="https://github.com/in-ch/tech-inverview-study/assets/49556566/e9636c30-a4b2-43e5-888b-deb5bedcaf59">

- 연속할당방식은 하나의 프로세스에 필요한 메모리들은 반드시 연속해서 메모리공간에 위치해야한다.
- 불연속할당방식은 하나의 프로세스에 필요한 메모리들이 연속해서 메모리공간에 위치하지 않아도 된다.

### 고정 분할 방식
장점

- 원리가 단순하다.
- 시스템 생성 시 미리 주기억장치가 분할되므로 `운영체제 오버헤드가 줄어든다.`

단점

- 외부 단편화 : 프로세스가 파티션보다 크면 Overlay 기법(프로세스의 필효나 부분만 적재)을 사용해야한다. 그만큼 오버헤드가 발생한다.
- 내부 단편화 : 파티션보다 작은 프로세스가 들어가면 남는 공간에서 내부 단편화가 발생한다.
- 낮은 융통성 : 하나의 분할에 하나의 프로그램만 적재할 수 있기 때문에, `동시에 메모리에 올릴 수 있는 프로그램의 수가 고정`되어있으며, 수행 가능한 프로그램의 크기도 고정되어있어서 가변분할 방식에 비해 융통성이 떨어진다.

### 가변 분할 방식
메모리에 적재되는 `프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식.`

연속할당 방식 중 하나.

장점

- 가변 분할 방식에서 분할의 크기를 일부러 프로그램보다 크게 설정하지는 않기 때문에 `내부 단편화가 생기지는 않는다.`
- 고정 분할 방식에 비해서 융통성이 있다.

단점

- 외부 단편화 : 메모리에 존재하는 프로그램이 `종료된 자리에 외부 단편화가 발생한다.`
- `동적 메모리 할당 문제(dynamic storage-allocation problem)`를 고려해야 한다.

### 불연속 할당 방식
- 페이지 테이블, 계층적 페이징, 역페이지 테이블, 공유 페이지, 세그먼테이션, 페이지드 세그멘테이션, 가상 메모리 등등이 있다. 